#!/usr/bin/python3
import sys
import ldap
import ldap.modlist

# uri = "ldaps://ldap.scz-vm.net"
uri = "ldapi:///"
binddn = "cn=admin,dc=services,dc=vnet"
passwd = "changethispassword"
ldap.set_option(ldap.OPT_X_TLS_REQUIRE_CERT, 0)
ldap.set_option(ldap.OPT_X_TLS_DEMAND, True)
ldapc = ldap.initialize(uri)
# ldapc.simple_bind_s(binddn, passwd)
ldapc.sasl_external_bind_s()

changed = 0

if len(sys.argv) < 2:
    exit(1)

basedn = sys.argv[1]
users = sys.argv[2:]

print(f"basedn: {basedn}")


def encode(entry):
    r = {}
    for k, v in entry.items():
        rv = []
        for ev in v:
            rv.append(str(ev).encode('UTF-8'))
        r[k] = rv
    return r


def store_user(dn, user, new_entry):
    global changed, basedn
    dst_dns = ldapc.search_s(basedn, ldap.SCOPE_ONELEVEL, f"(cn={user})")
    if len(dst_dns) == 1:
        dn, entry = dst_dns[0]
        modifylist = ldap.modlist.modifyModlist(encode(entry),
                                                encode(new_entry))
        ldapc.modify_s(dn, modifylist)
    elif len(dst_dns) == 0:
        addlist = ldap.modlist.addModlist(encode(new_entry))
        ldapc.add_s(dn, addlist)
        changed = 1
    else:
        print("Too many dn's This shouldn't happen")


def get_admins():
    global basedn
    admins = []
    s = ldapc.search_s(basedn, ldap.SCOPE_ONELEVEL,
                       '(objectClass=organizationalRole)', ['dn'])
    for entry in s:
        dn, _ = entry
        parts = ldap.dn.str2dn(dn)
        attr, user, _ = parts[0][0]
        admins.append(user)
    return admins


admins = get_admins()

# This is if we want to keep the original platform admin user
admins.remove('admin')

print(f"admins {admins}")

new_entry = {
    'objectClass': ['organizationalRole', 'simpleSecurityObject'],
}

# provision admin users
for item in users:
    user, password = item.split(',')
    if user == 'admin':
        continue
    print(f"add user: {user}")
    print(f"add password: {password}")
    dn = f"cn={user},{basedn}"
    new_entry['cn'] = [user]
    new_entry['userPassword'] = ["{CRYPT}"+password]
    store_user(dn, user, new_entry)
    if user in admins:
        admins.remove(user)

print(f"admins {admins}")

# deprovision existing admins
for admin in admins:
    print(f"remove admin: {admin}")
    ldapc.delete_s(f"cn={admin},{basedn}")
    changed = 1

exit(changed)
